# Semantic Kernel Tutorials

📚 Semantic Kernel Components(구성요소)
## 1. AI 서비스 커넥터

- 여러 AI 서비스 유형을 노출하는 추상화 계층을 제공
- 채팅 완성, 텍스트 생성, 임베딩 생성, 텍스트-이미지 변환, 이미지-텍스트 변환, 텍스트-오디오 변환, 오디오-텍스트 변환..
- 구현이 커널에 등로되면 채팅완성(IChatCompletionService), 텍스트생성(ITextGenerationService) 서비스 사용, 다른 서비스는 자동 사용 안된다.

## 2. 벡터 저장소(메모리) 커넥터

- 다양한 제공업체의 벡터 저장소를 노출하는 추상화 계층을 제공
- 자세한 페이지(추후)
## 3. 함수 및 플러그인

- 플러그인은 이름이 지정된 함수 컨테이너(집합)
- 플러그인은 커널에 등록될 수 있으며, 이를 통해 커널은 두 가지 방식으로 플러그인을 사용할 수 있다.
    - 채팅 완료 AI에 광고하여 AI가 호출할 때 선택할 수 있도록 합니다.
    - 템플릿 렌더링 중에 템플릿에서 호출할 수 있도록 합니다.
- 네이티브 코드, OpenAPI 사양, `ITextSearch`RAG 시나리오 구현은 물론 프롬프트 템플릿을 포함한 다양한 소스에서 함수를 쉽게 생성
    
    ![image](https://github.com/user-attachments/assets/110aa55c-86c6-45d5-af29-2ccfb941c0fa)

## 4. Prompt Template (프롬프트 템플릿)

- AI에 대한 컨텍스트 및 지침과 사용자 입력 및 기능 출력을 결합한 템플릿 생성
- 채팅 완료 AI 모델에 대한 지침, 사용자 입력을 위한 플레이스홀더
- 채팅 완료 AI 모델을 호출하기 전에 항상 실행되어야 하는 플러그인에 대한 하드코딩된 호출
- 프롬프트 템플릿은 두 가지 방법으로 사용할 수 있다.
    - 커널에 템플릿을 렌더링하고 렌더링된 결과로 채팅 완성 AI 모델을 호출하도록 요청하여 채팅 완성 흐름의 시작점으로 사용한다.
    - 플러그인 함수이므로 다른 함수와 같은 방식으로 호출할 수 있다.
- 자세한 페이지(추후)
  
![image](https://github.com/user-attachments/assets/9cf9cb1d-31f8-49c9-b87c-7961ff74310b)

## **5. Filter (필터)**

- 필터는 채팅 완료 흐름 중 **특정 이벤트 전후에 사용자 지정 작업**을 수행할 수 있는 방법을 제공
    - 함수 호출 전과 후 흐름제어.
    - 즉시 렌더링 전과 후.
- 프롬프트 템플릿은 실행 전에 항상 KernelFunction으로 변환되므로, 함수 필터와 프롬프트 필터가 모두 프롬프트 템플릿에 대해 호출된다.
- 필터가 두 개 이상 사용 가능한 경우 중첩되므로, 함수 필터는 바깥쪽 필터이고 프롬프트 필터는 안쪽 필터이다.
![image](https://github.com/user-attachments/assets/7e8ca690-7a0d-4235-8679-572cc9c73d12)

- 필터는 함수 실행 방식과 시점에 대한 제어 및 가시성을 제공하여 보안을 강화
- 예를 들어, **필터는 승인 흐름이 시작되기 전에 권한을 검증하는 데 활용**
- 필터는 승인을 제출하려는 사람의 권한을 확인하기 위해 실행됩니다. 즉, **선택된 그룹만 프로세스를 시작할 수 있다**.
![image](https://github.com/user-attachments/assets/e4c7663c-feea-4afe-8ec7-8ab767811b87)

- **PromptFilters**: 프롬프트 실행 전후 (텍스트 변경 등)
- **FunctionFilters**: 함수 실행 전후 (입력/출력 제어)

🧪 예시:

- 입력 프롬프트를 감시해 금지어가 있으면 수정
- 출력 결과에 후처리(ex. 요약, 포맷 변경)
- 특정 시간대엔 실행 못 하게 제한
